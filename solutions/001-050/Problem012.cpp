/* Highly divisible triangular number
 * The sequence of triangle numbers is generated by adding the
 * natural numbers. So the 7th triangle number would be
 * 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
 *
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 *
 * Let us list the factors of the first seven triangle numbers:
 *
 *   1: 1
 *   3: 1,3
 *   6: 1,2,3,6
 *  10: 1,2,5,10
 *  15: 1,3,5,15
 *  21: 1,3,7,21
 *  28: 1,2,4,7,14,28
 *
 * We can see that 28 is the first triangle number to have over
 * five divisors.
 *
 * What is the value of the first triangle number to have over
 * five hundred divisors? */

#include <iostream>
#include <vector>
#include <cmath>

void listFactors(unsigned);
bool isPrime(long long);
long long triNum(long long);
typedef std::vector<long long> PF_vect;
std::vector<unsigned> getPrimeOccurrences(long long triNum, const PF_vect &);
unsigned countAllFactors(const std::vector<unsigned> &);
void simpleSolution();

int main() {
    //listFactors(2*2*3*5*5*5);
    simpleSolution();
}

void listFactors(unsigned limit) {
    int factors = 0;
    for( int i=1; i<=limit; ++i )
        if( limit%i == 0 ) ++factors, std::cout << i << ' ';
    std::cout << "\nfactors: " << factors <<std::endl;
}
bool isPrime(long long n) {
    if( n==1 ) return false;
    else if( n<4 ) return true;
    else if( n%2 == 0 ) return false;
    else if( n<9 ) return true;
    else if( n%3 == 0 ) return false;
    else {
        auto r = static_cast<long long>( std::floor( std::sqrt( static_cast<float>(n) ) ) );
        long long f = 5;
        while( f<=r ) {
            if( n%f == 0 ) return false;
            if( n%(f+2) == 0 ) return false;
            f += 6;
        }
        return true;
    }
}
long long triNum(long long num) {
    long long result = 0;
    for( long long i=1; i<=num; ++i ) result += i;
    return result;
}
std::vector<unsigned> getPrimeOccurrences(long long triNum,
                                     const PF_vect &primesList) {
    // create vector of prime occurrences
    std::vector<unsigned> primeOccurrences;
    size_t n=0;
    while( triNum > 1 && primesList[n] <= triNum )
        if (triNum % primesList[ n ] == 0) { // found prime factor
            primeOccurrences.push_back(0);
            while (triNum % primesList[ n ] == 0) {
                triNum /= primesList[ n ];
                ++*(primeOccurrences.end() - 1);
            }
            ++n;
        } else ++n;

    return primeOccurrences;
}
unsigned countAllFactors(const std::vector<unsigned> &pf_occurrences) {
    /* This algorithm finds divisors of a number using its prime
     * factors, mainly the occurrences of each unique prime factor.
     *
     * For example, let's take some number a*a*b*c*c*c, where a,b,c
     * are any prime numbers. We can see that there are 3 unique prime
     * numbers, with frequencies of occurrence of 2,1,& 3, respectively.
     * The number of divisors can then be found as the sum of 3 numbers,
     * or however many unique primes there are, as follows:
     *
     * - num1 = occurrence of a
     *        = O_a = 2
     * - num2 = O_b * ( num1 + 1 )
     *        = 1 * ( 2 + 1 ) = 3
     * - num3 = O_c * ( num1 + num2 + 1 )
     *        = 3 * ( 2 + 3 + 1 ) = 18
     * - totalDivisors = num1 + num2 + num3 + 1
     *                 = 2 + 3 + 18 + 1
     *                 = 24
     *
     * It should be noted that order does not matter, due to commutative
     * property of multiplication. */
    unsigned numOfPrimes = pf_occurrences.size();
    unsigned partialSum = pf_occurrences[0];
    for( int i=1; i<numOfPrimes; ++i )
        partialSum += pf_occurrences[i] * ( partialSum + 1 );

    return partialSum + 1;
}
void simpleSolution() {
    // calculate first 1000 primes
    unsigned primesLimit = 1000;
    std::vector<long long> primes(primesLimit,0);
    primes[0] = 2;
    {
        long long num = 3;
        for( auto i=1U; i<primesLimit; ++i ) {
            while( !isPrime(num) ) num += 2;
            primes.at(i) = num;
            num += 2;
        }
    }

    int factors=0;
    long long nthNum=1;
    long long triangularNum = triNum(nthNum);
    auto occurrences = getPrimeOccurrences(triangularNum,primes);
    while( factors<500 ) {
        triangularNum = triNum(++nthNum);
        occurrences = getPrimeOccurrences(triangularNum,primes);
        factors = countAllFactors(occurrences);
    }

    std::cout << "result: " << triangularNum << std::endl;
}
